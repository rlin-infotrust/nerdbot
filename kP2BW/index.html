<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Nerdbot 5000: Validation Results</title>
  <style>
    body {
      font-family: 'Roboto Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
      background: #181818;
      color: #e0e0e0;
    }
    table {
      border-collapse: collapse;
      margin: 2em auto;
      width: 90%;
      background: #232323;
      color: #e0e0e0;
    }
    th, td {
      border: 1px solid #444;
      padding: 8px 12px;
      text-align: left;
      word-break: break-word;
      overflow-wrap: break-word;
    }
    th {
      background: #252526;
      color: #c586c0;
    }
    tr:nth-child(even) {
      background: #202124;
    }

    a {
      color: yellow;
      text-decoration: none;
    }
    a:hover {
      color: black;
      background-color: yellow;
    }

  </style>
</head>
<body>
  <h2 style="text-align:center;">ðŸ¤– Nerdbot 5000 ðŸ¤–</h2>

  <h3 style="text-align:center;">Validation Results</h3>
  <table id="manifestTable">
    <thead>
      <tr id="manifestHeader"></tr>
    </thead>
    <tbody id="manifestBody"></tbody>
  </table>

  <!-- Search bar for filtering results tables -->
  <div style="width:90%;margin:0 auto 2em auto;">
    <input
      id="resultsSearch"
      type="text"
      placeholder="Search results..."
      style="width:100%;font-size:18px;padding:8px 12px;border-radius:3px;border:1px solid #444;background:#232323;color:#fff;"
      autocomplete="off"
    />
  </div>

  <div id="results"></div>

  <script>
  // Store all loaded data for filtering
  let allResultsData = [];

  // Main render function: fetch manifest.json once and render everything
  async function renderAll() {
    const rs = await fetch("manifest.json");
    if (!rs.ok) throw new Error('Failed to fetch JSON');
    const json = await rs.json();
    console.log('Manifest JSON loaded:', json);

    renderManifest(json);
    await renderResultsTables(json); // Await so allResultsData is populated
  }

  function renderManifest(json) {
    const manifestHeader = document.getElementById('manifestHeader');
    const manifestBody = document.getElementById('manifestBody');
    manifestHeader.innerHTML = '';
    manifestBody.innerHTML = '';

    // If manifest is an array, use first element; else use as object
    const manifestObj = Array.isArray(json) ? json[0] : json;
    if (!manifestObj || typeof manifestObj !== 'object') {
      manifestHeader.innerHTML = '<th>No manifest data</th>';
      return;
    }

    // Headers
    const keys = Object.keys(manifestObj);
    keys.forEach(key => {
      const th = document.createElement('th');
      th.textContent = key;
      manifestHeader.appendChild(th);
    });

    // Values
    const tr = document.createElement('tr');
    keys.forEach(key => {
      const td = document.createElement('td');
      // Pretty print arrays/objects
      if (key === 'dt' && typeof manifestObj[key] === 'string') {
        // Convert UTC ISO string to Eastern Time
        const date = new Date(manifestObj[key]);
        // Use Intl.DateTimeFormat for America/New_York
        const eastern = new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(date);
        td.textContent = eastern;
      } else if (typeof manifestObj[key] === 'object') {
        td.innerHTML = manifestObj[key].map(item => `${item.id}. ${item.url}`).join('<br />');
      } else {
        td.textContent = manifestObj[key];
      }
      tr.appendChild(td);
    });
    manifestBody.appendChild(tr);
  }

  async function renderResultsTables(json) {
    const manifestObj = Array.isArray(json) ? json[0] : json;
    if (!manifestObj || !Array.isArray(manifestObj.pageUrls)) return;

    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = ''; // Clear previous tables
    allResultsData = []; // Reset

    for (const page of manifestObj.pageUrls) {
      // Fetch data for this page
      let data = [];
      try {
        const rs = await fetch(`${page.id}.json`);
        if (rs.ok) {
          const pageJson = await rs.json();
          data = Array.isArray(pageJson) ? pageJson : (pageJson.rows || []);
        }
      } catch (e) {
        // ignore
      }
      allResultsData.push({ page, data });
    }
    renderFilteredResults();
  }

  // Helper: get a color for each keyword index
  function getHighlightColor(idx) {
    // Pick from a palette, cycle if more than palette length
    const palette = [
      '#fff200', // yellow
      '#00e6ff', // cyan
      '#ff7f50', // coral
      '#90ee90', // lightgreen
      '#ff69b4', // pink
      '#ffa500', // orange
      '#b366ff', // purple
      '#00ff99', // mint
      '#ff4444', // red
      '#00ffcc'  // teal
    ];
    return palette[idx % palette.length];
  }

  // Helper to highlight all keywords in a string with different colors
  function highlightKeywords(text, keywords) {
    if (!keywords.length) return text;
    let result = text;
    // To avoid overlapping tags, replace all at once using a global regex
    // Sort keywords by length descending to avoid nested highlights
    const sortedKeywords = keywords
      .map((kw, idx) => ({kw, idx}))
      .filter(obj => obj.kw)
      .sort((a, b) => b.kw.length - a.kw.length);

    sortedKeywords.forEach(({kw, idx}) => {
      if (!kw) return;
      const safeKw = kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const color = getHighlightColor(idx);
      // Use a unique marker to avoid double-highlighting
      const markerStart = `__MARKER${idx}__`;
      const markerEnd = `__ENDMARKER${idx}__`;
      const regex = new RegExp(`(${safeKw})`, 'gi');
      result = result.replace(regex, `${markerStart}$1${markerEnd}`);
      // After all keywords, replace markers with span
      result = result
        .replace(new RegExp(markerStart, 'g'), `<span style="background:${color};color:black;">`)
        .replace(new RegExp(markerEnd, 'g'), '</span>');
    });
    return result;
  }

  // Render all tables, filtered by search input
  function renderFilteredResults() {
    const searchInput = document.getElementById('resultsSearch').value.trim().toLowerCase();
    const keywords = searchInput.split(',').map(s => s.trim()).filter(Boolean);
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '';

    for (const { page, data } of allResultsData) {
      // Filter data rows by ANY keyword (OR logic)
      const filtered = !keywords.length
        ? data
        : data.filter(row => {
            const rowText = Object.values(row).join(' ').toLowerCase();
            return keywords.some(kw => rowText && kw && rowText.includes(kw));
          });

      // --- Summary Table: count keyword matches in this table ---
      const keywordCounts = keywords.map(kw => {
        if (!kw) return 0;
        let count = 0;
        filtered.forEach(row => {
          Object.values(row).forEach(val => {
            const cell = String(val).toLowerCase();
            // Count all non-overlapping matches in this cell
            if (kw) {
              const matches = cell.match(new RegExp(kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'));
              if (matches) count += matches.length;
            }
          });
        });
        return count;
      });

      // Section and title
      const section = document.createElement('section');
      section.style.margin = "2em 0";
      const h4 = document.createElement('h4');
      h4.innerHTML = `Results for: ${page.url} ðŸ“¸ <a href="${page.id}.png">[screenshot]</a>`;
      h4.style.color = "#c586c0";
      section.appendChild(h4);

      // --- Render summary table if there are keywords ---
      if (keywords.length) {
        const summaryTable = document.createElement('table');
        summaryTable.style.width = "auto";
        summaryTable.style.margin = "0 0 1em 0";
        summaryTable.style.background = "#232323";
        summaryTable.style.color = "#e0e0e0";
        summaryTable.style.borderCollapse = "collapse";
        summaryTable.style.fontSize = "13px";

        const thead = document.createElement('thead');
        const trHead = document.createElement('tr');
        keywords.forEach((kw, idx) => {
          const th = document.createElement('th');
          th.textContent = kw || '(empty)';
          th.style.background = "#252526";
          th.style.color = "#232323";
          th.style.border = "1px solid #444";
          th.style.padding = "4px 8px";
          th.style.background = getHighlightColor(idx);
          trHead.appendChild(th);
        });
        thead.appendChild(trHead);
        summaryTable.appendChild(thead);

        const tbody = document.createElement('tbody');
        const trBody = document.createElement('tr');
        keywordCounts.forEach((count, idx) => {
          const td = document.createElement('td');
          td.textContent = count;
          td.style.border = "1px solid #444";
          td.style.padding = "4px 8px";
          td.style.background = getHighlightColor(idx);
          td.style.color = "#232323";
          trBody.appendChild(td);
        });
        tbody.appendChild(trBody);
        summaryTable.appendChild(tbody);

        section.appendChild(summaryTable);
      }

      // Table
      const table = document.createElement('table');
      table.style.width = "90%";
      table.style.margin = "1em auto";
      table.style.background = "#232323";
      table.style.color = "#e0e0e0";
      table.style.borderCollapse = "collapse";
      table.style.fontSize = "14px";

      if (filtered.length) {
        // Table header
        const thead = document.createElement('thead');
        const trHead = document.createElement('tr');
        Object.keys(filtered[0]).forEach(key => {
          const th = document.createElement('th');
          th.textContent = key;
          th.style.background = "#252526";
          th.style.color = "#c586c0";
          th.style.border = "1px solid #444";
          th.style.padding = "8px 12px";
          // Set fixed width for "method" and "type" columns
          if (key === 'method' || key === 'type') {
            th.style.width = "80px";
            th.style.minWidth = "80px";
            th.style.maxWidth = "80px";
          }
          trHead.appendChild(th);
        });
        thead.appendChild(trHead);
        table.appendChild(thead);

        // Table body
        const tbody = document.createElement('tbody');
        filtered.forEach(row => {
          const tr = document.createElement('tr');
          Object.keys(filtered[0]).forEach(key => {
            const td = document.createElement('td');
            const cellText = String(row[key]);
            td.innerHTML = keywords.length && cellText
              ? highlightKeywords(cellText, keywords)
              : cellText;
            td.style.border = "1px solid #444";
            td.style.padding = "8px 12px";
            // Set fixed width for "method" and "type" columns
            if (key === 'method' || key === 'type') {
              td.style.width = "80px";
              td.style.minWidth = "80px";
              td.style.maxWidth = "80px";
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
      } else {
        // No data
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.textContent = "No data";
        tr.appendChild(td);
        table.appendChild(tr);
      }

      section.appendChild(table);
      resultsDiv.appendChild(section);
    }
  }

  // Utility to get URL parameter by name
  function getQueryParam(name) {
    const params = new URLSearchParams(window.location.search);
    return params.get(name);
  }

  // Call the main render function
  renderAll();

  // Listen for search input and populate from URL param "s" on load
  document.addEventListener('DOMContentLoaded', () => {
    // Populate search bar from ?s= param if present
    const sParam = getQueryParam('s');
    if (sParam !== null) {
      document.getElementById('resultsSearch').value = sParam;
    }
    document.getElementById('resultsSearch').addEventListener('input', renderFilteredResults);
    // Trigger initial filter in case search bar was populated
    renderFilteredResults();
  });
  </script>


</body>
</html>